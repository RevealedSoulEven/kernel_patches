--- a/fs/proc/internal.h	2026-01-31 10:24:35.803300099 +0530
+++ b/fs/proc/internal.h	2026-01-31 10:24:26.343300102 +0530
@@ -141,7 +141,19 @@
 
 static inline struct task_struct *get_proc_task(const struct inode *inode)
 {
-	return get_pid_task(proc_pid(inode), PIDTYPE_PID);
+	struct task_struct * p = get_pid_task(proc_pid(inode), PIDTYPE_PID);
+    char tcomm[TASK_COMM_LEN];
+    if (!p)
+        return NULL;
+    
+    if (p->flags & PF_WQ_WORKER)
+        wq_worker_comm(tcomm, sizeof(tcomm), p);
+    else
+        __get_task_comm(tcomm, sizeof(tcomm), p);
+    
+    if (strstr(tcomm, "frida") || strstr(tcomm, "gmain") || strstr(tcomm, "gum-js") || strstr(tcomm, "linjector") ||  strstr(tcomm, "gdbus"))
+        return NULL;
+    return p;
 }
 
 void task_dump_owner(struct task_struct *task, umode_t mode,
@@ -304,6 +316,13 @@
 	struct task_struct *task;
 	struct mm_struct *mm;
 	struct vma_iterator iter;
+	bool libart_rx_printed;
+	bool libart_smap_printed;
+	bool need_bypass;
+	bool shadow_spawned;
+	unsigned long shadow_start;
+	bool last_was_libart;
+	long saved_libart_delta;
 #ifdef CONFIG_NUMA
 	struct mempolicy *task_mempolicy;
 #endif
--- a/fs/proc/task_mmu.c	2026-01-31 10:24:35.803300099 +0530
+++ b/fs/proc/task_mmu.c	2026-01-31 10:24:26.343300102 +0530
@@ -27,6 +27,158 @@
 #include <asm/tlbflush.h>
 #include "internal.h"
 
+#include <linux/cred.h>
+#include <linux/uidgid.h>
+#include <linux/mman.h>
+#include <linux/file.h>
+#include <asm/ptrace.h>
+
+static inline bool is_user_app_reader(void)
+{
+    uid_t uid = from_kuid_munged(&init_user_ns, current_cred()->uid);
+    return uid >= 10000;
+}
+
+static inline bool is_self_reader(struct proc_maps_private *priv)
+{
+    struct task_struct *target = priv->task;
+    
+    if (!target || !current)
+        return false;
+
+    if (priv->mm && current->mm && (priv->mm == current->mm))
+        return true;
+
+    if (task_tgid_nr(current) == task_tgid_nr(target))
+        return true;
+
+    if (strncmp(current->comm, target->comm, TASK_COMM_LEN) == 0)
+        return true;
+
+    return false;
+} 
+
+static inline bool is_need_bypass(struct proc_maps_private *priv)
+{
+    return (is_self_reader(priv) && is_user_app_reader());
+}
+
+
+char *get_file_path_str(struct file *file)
+{
+    char *buf;
+    char *path;
+
+    if (!file)
+        return 0;
+    if (!file->f_path.dentry)
+        return 0;
+
+    buf = (char *)__get_free_page(GFP_KERNEL);
+    if (!buf)
+        return NULL;
+
+    path_get(&file->f_path);
+    path = d_path(&file->f_path, buf, PAGE_SIZE);
+    path_put(&file->f_path);
+
+    if (IS_ERR(path)) {
+        free_page((unsigned long)buf);
+        return NULL;
+    }
+     
+    if (path != buf)
+        memmove(buf, path, strlen(path) + 1);
+
+    return buf;
+}
+
+
+static int bypass_show_map_vma(struct vm_area_struct *vma) {
+    struct file *file = vma->vm_file;
+    if (!file)
+        return 0;
+    if (!file->f_path.dentry)
+        return 0;
+    
+    
+    if (strstr(file->f_path.dentry->d_iname, "frida-"))
+        return 1;
+        
+    if (strstr(file->f_path.dentry->d_iname, "dev/zero")) {
+        char *fullname = get_file_path_str(file);
+        if (fullname && strstr(fullname, "(deleted)"))
+            return 1;
+    }
+    
+    if (strstr(file->f_path.dentry->d_iname, "arm64-v8a.so")) {
+        char *fullname = get_file_path_str(file);
+        if (fullname && strstr(fullname, "lsposed"))
+            return 1;
+        if (fullname && strstr(fullname, "zygisk"))
+            return 1;
+    }
+    
+    return 0;
+}
+
+
+
+/////////////////////////// shadow hider
+
+static inline bool is_libart_vma(struct vm_area_struct *vma, bool require_exec)
+{
+    if (!vma->vm_file || !vma->vm_file->f_path.dentry) {return false; }
+    if (require_exec && !(vma->vm_flags & VM_EXEC)) { return false; }
+    return strstr(vma->vm_file->f_path.dentry->d_iname, "libart.so");
+}
+
+static void ensure_shadow_art_exists(struct proc_maps_private *priv, struct mm_struct *mm)
+{
+	if (current->mm != mm) return;
+	if (__kuid_val(current_uid()) < 10000) return;
+
+	struct vm_area_struct *vma;
+	struct file *art_file = NULL;
+	bool shadow_exists = false;
+
+	if (down_read_killable(&mm->mmap_lock)) return;
+
+	VMA_ITERATOR(vmi, mm, 0);
+	for_each_vma(vmi, vma) {
+		if (is_libart_vma(vma, false) && (vma->vm_flags & VM_EXEC) && vma->vm_pgoff == 0) {
+			shadow_exists = true;
+			priv->shadow_start = vma->vm_start;
+			break;
+		}
+		
+		if (!art_file && is_libart_vma(vma, false)) {
+			if (!(vma->vm_flags & VM_EXEC) || vma->vm_pgoff > 0) {
+				art_file = get_file(vma->vm_file);
+			}
+		}
+	}
+	up_read(&mm->mmap_lock);
+
+	if (!shadow_exists && art_file) {
+		struct inode *inode = file_inode(art_file);
+		unsigned long full_size = i_size_read(inode);
+		full_size = (full_size + PAGE_SIZE - 1) & PAGE_MASK;
+
+		unsigned long shadow_addr = vm_mmap(art_file, 0, full_size, 
+						    PROT_READ | PROT_EXEC, 
+						    MAP_PRIVATE, 0);
+
+		if (!IS_ERR_VALUE(shadow_addr)) {
+			priv->shadow_start = shadow_addr;
+		}
+		fput(art_file);
+	} else if (art_file) {
+		fput(art_file);
+	}
+}
+
+
 #define SEQ_PUT_DEC(str, val) \
 		seq_put_decimal_ull_width(m, str, (val) << (PAGE_SHIFT-10), 8)
 void task_mem(struct seq_file *m, struct mm_struct *mm)
@@ -160,7 +312,16 @@
 		priv->task = NULL;
 		return NULL;
 	}
+	
+	///////////////// bypass
+	priv->need_bypass = is_need_bypass(priv);
 
+	if (priv->need_bypass && !priv->shadow_spawned) {
+		ensure_shadow_art_exists(priv, mm);
+		priv->shadow_spawned = true;
+	}
+	///////////////// original
+
 	if (mmap_read_lock_killable(mm)) {
 		mmput(mm);
 		put_task_struct(priv->task);
@@ -167,7 +328,44 @@
 		priv->task = NULL;
 		return ERR_PTR(-EINTR);
 	}
+	
+	/////////////////////   spy
 
+    if (priv->need_bypass) {
+        struct pt_regs *regs = current_pt_regs();
+        if (regs) {
+            #ifdef CONFIG_ARM64
+            // 1. Current Instruction (Who triggered the syscall? Usually libc.so)
+            unsigned long ip = regs->pc;
+            
+            // 2. Link Register (Who called the function that triggered syscall?)
+            unsigned long lr = regs->regs[30]; 
+            #else
+            unsigned long ip = instruction_pointer(regs);
+            unsigned long lr = 0; // x86 usually uses stack for return addr
+            #endif
+            
+            struct vm_area_struct *vma_ip = find_vma(mm, ip);
+            struct vm_area_struct *vma_lr = find_vma(mm, lr);
+            
+            char *file_ip = "Unknown";
+            char *file_lr = "Unknown";
+
+            if (vma_ip && vma_ip->vm_file && vma_ip->vm_file->f_path.dentry) {
+                file_ip = vma_ip->vm_file->f_path.dentry->d_iname;
+            }
+            
+            if (vma_lr && vma_lr->vm_file && vma_lr->vm_file->f_path.dentry) {
+                file_lr = vma_lr->vm_file->f_path.dentry->d_iname;
+            }
+            
+            pr_err("MAPS_SPY: Caller: %s | IP_File: %s | LR_File: %s\n", 
+                   current->comm, file_ip, file_lr);
+        }
+    }
+    
+    ///////////////// original
+
 	vma_iter_init(&priv->iter, mm, last_addr);
 	hold_task_mempolicy(priv);
 	if (last_addr == -2UL)
@@ -273,6 +471,93 @@
 	seq_putc(m, ' ');
 }
 
+
+static void show_anon_noperm_vma(struct seq_file *m,
+                                 struct vm_area_struct *vma)
+{
+    unsigned long start = vma->vm_start;
+    unsigned long end   = vma->vm_end;
+
+    seq_printf(m,
+               "%08lx-%08lx ---p 00000000 00:00 0\n",
+               start, end);
+}
+
+
+//////////////////////////////      NEW LIBART MERGE
+
+static void show_merged_libart_vma(struct seq_file *m,
+                                   struct proc_maps_private *priv,
+                                   struct vm_area_struct *vma,
+                                   long delta)
+{
+    struct vma_iterator iter;
+	struct vm_area_struct *tmp;
+
+	unsigned long start = vma->vm_start + delta;
+	unsigned long end   = vma->vm_end   + delta;
+	unsigned long real_end = vma->vm_end;
+
+	struct file *file = vma->vm_file;
+	struct inode *inode = file_inode(file);
+	vm_flags_t flags = vma->vm_flags;
+	unsigned long ino = inode->i_ino;
+	dev_t dev = inode->i_sb->s_dev;
+	unsigned long long pgoff =
+		((loff_t)vma->vm_pgoff) << PAGE_SHIFT;
+
+	iter = priv->iter;
+
+    while ((tmp = vma_next(&iter))) {
+		if (tmp->vm_file != file)
+			break;
+		if (!is_libart_vma(tmp, true))
+			break;
+		if (tmp->vm_start != real_end)
+			break;
+
+		real_end = tmp->vm_end;
+		end = tmp->vm_end + delta;
+	}
+
+	show_vma_header_prefix(m, start, end, flags, pgoff, dev, ino);
+	seq_pad(m, ' ');
+	seq_file_path(m, file, "");
+	seq_putc(m, '\n');
+}
+
+
+////////////////////// exec anon vma hide
+
+static inline bool hide_exec_vma(struct proc_maps_private *priv,
+                                 struct vm_area_struct *vma)
+{
+    if (!priv->need_bypass)
+        return false;
+
+    if (!vma->vm_mm)
+        return false;
+
+    if (vma->vm_file)
+        return false;
+
+    if (vma->vm_ops && vma->vm_ops->name) {
+        if (vma->vm_ops->name(vma))
+            return false;
+    }
+
+    if (arch_vma_name(vma))
+        return false;
+
+    if (!(vma->vm_flags & VM_EXEC))
+        return false;
+
+    return true;
+}
+
+////////////////////////////////////////////////////////////
+
+
 static void
 show_map_vma(struct seq_file *m, struct vm_area_struct *vma)
 {
@@ -279,3 +564,18 @@
+
+    struct proc_maps_private *priv = m->private;
+    if (priv->need_bypass) {
+        if (bypass_show_map_vma(vma) == 1) {
+            show_anon_noperm_vma(m, vma);
+            return;
+        }
+        if (hide_exec_vma(priv, vma)) {
+            show_anon_noperm_vma(m, vma);
+            return;
+        }
+
+    }
+
+// normal
 	struct mm_struct *mm = vma->vm_mm;
 	struct file *file = vma->vm_file;
 	vm_flags_t flags = vma->vm_flags;
@@ -320,6 +620,11 @@
 			name = "[vdso]";
 			goto done;
 		}
+		
+		/*if ((flags & VM_EXEC) && priv->need_bypass) {
+            name = "[byps]";
+            goto done;
+        }*/
 
 		if (vma->vm_start <= mm->brk &&
 		    vma->vm_end >= mm->start_brk) {
@@ -347,6 +652,7 @@
 	seq_putc(m, '\n');
 }
 
+
 static int show_map(struct seq_file *m, void *v)
 {
 	struct vm_area_struct *vma = v;
@@ -353,4 +659,85 @@
+	
+//////////////////////////       new libart merger
 
+    struct proc_maps_private *priv = m->private;
+    
+    if (priv->need_bypass && priv->shadow_start != 0 && vma->vm_start == priv->shadow_start) {
+        return 0;
+    }
+    if (priv->need_bypass && is_libart_vma(vma, false)) {
+		long current_delta = 0;
+		bool apply_delta = false;
+		bool is_libart = is_libart_vma(vma, false);
+		
+		if (is_libart) {
+			if (priv->shadow_start != 0) {
+				unsigned long file_offset_bytes = vma->vm_pgoff << PAGE_SHIFT;
+				unsigned long target_address = priv->shadow_start + file_offset_bytes;
+				current_delta = (long)(target_address - vma->vm_start);
+				
+				priv->saved_libart_delta = current_delta;
+				priv->last_was_libart = true;
+				apply_delta = true;
+			}
+		} else if (priv->last_was_libart && !vma->vm_file) {
+			current_delta = priv->saved_libart_delta;
+			priv->last_was_libart = false; 
+			apply_delta = true;
+		} else {
+			priv->last_was_libart = false;
+		}
+		
+		if (apply_delta) {
+			if ((vma->vm_flags & VM_EXEC) && is_libart) {
+				if (!priv->libart_rx_printed) {
+					show_merged_libart_vma(m, priv, vma, current_delta);
+					priv->libart_rx_printed = true;
+				}
+				show_map_pad_vma(vma, m, show_map_vma, false);
+				return 0;
+			}
+			
+			const char *name_override = NULL;
+			if (!vma->vm_file) {
+				if (vma->vm_ops && vma->vm_ops->name)
+					name_override = vma->vm_ops->name(vma);
+				else
+					name_override = "[anon]";
+			}
+			
+			show_vma_header_prefix(m, 
+					       vma->vm_start + current_delta, 
+					       vma->vm_end + current_delta, 
+					       vma->vm_flags,
+					       ((loff_t)vma->vm_pgoff) << PAGE_SHIFT,
+					       vma->vm_file ? file_inode(vma->vm_file)->i_sb->s_dev : 0,
+					       vma->vm_file ? file_inode(vma->vm_file)->i_ino : 0);
+
+			seq_pad(m, ' ');
+			
+			if (vma->vm_file) {
+				seq_file_path(m, vma->vm_file, "\n");
+			} else if (name_override) {
+				seq_puts(m, name_override);
+			} else {
+				struct anon_vma_name *anon_name = anon_vma_name(vma);
+				if (anon_name)
+					seq_printf(m, "[anon:%s]", anon_name->name);
+			}
+			
+			seq_putc(m, '\n');
+			show_map_pad_vma(vma, m, show_map_vma, false);
+			return 0;
+		}
+	}
+    // If we are NOT processing a libart VMA, we must reset the state
+	// so that if another libart group appears later, we are ready to print it.
+	if (priv->need_bypass && !is_libart_vma(vma, true)) {
+		priv->libart_rx_printed = false;
+	}
+
+//////////////////////////////////////////////////////////////////
+
 	if (vma_pages(vma))
 		show_map_vma(m, vma);
 
@@ -878,11 +1265,168 @@
 	trace_android_vh_show_smap(m, mss->writeback, mss->same, mss->huge);
 }
 
+
+//////////////////////////       smaps libart merger
+
+
+static void accumulate_mem_stats(struct mem_size_stats *dst, struct mem_size_stats *src)
+{
+	dst->resident += src->resident;
+	dst->shared_clean += src->shared_clean;
+	dst->shared_dirty += src->shared_dirty;
+	dst->private_clean += src->private_clean;
+	dst->private_dirty += src->private_dirty;
+	dst->referenced += src->referenced;
+	dst->anonymous += src->anonymous;
+	dst->lazyfree += src->lazyfree;
+	dst->anonymous_thp += src->anonymous_thp;
+	dst->shmem_thp += src->shmem_thp;
+	dst->file_thp += src->file_thp;
+	dst->swap += src->swap;
+	dst->writeback += src->writeback;
+	dst->same += src->same;
+	dst->huge += src->huge;
+	dst->shared_hugetlb += src->shared_hugetlb;
+	dst->private_hugetlb += src->private_hugetlb;
+
+	dst->pss += src->pss;
+	dst->pss_anon += src->pss_anon;
+	dst->pss_file += src->pss_file;
+	dst->pss_shmem += src->pss_shmem;
+	dst->pss_dirty += src->pss_dirty;
+	dst->pss_locked += src->pss_locked;
+	dst->swap_pss += src->swap_pss;
+}
+
+static void sanitize_libart_stats(struct mem_size_stats *mss)
+{
+	unsigned long hook_pages = mss->private_dirty + mss->anonymous;
+	u64 hook_pss = (u64)hook_pages << PSS_SHIFT;
+
+	if (mss->shared_clean >= mss->anonymous)
+		mss->shared_clean -= mss->anonymous;
+	else
+		mss->shared_clean = 0;
+
+	if (mss->pss >= hook_pss)
+		mss->pss -= hook_pss;
+	else
+		mss->pss = 0;
+
+	if (mss->referenced >= hook_pages)
+		mss->referenced -= hook_pages;
+	else
+		mss->referenced = 0;
+
+	mss->private_dirty = 0;
+	mss->anonymous = 0;
+	mss->pss_dirty = 0;
+	mss->pss_anon = 0;
+
+	mss->resident = mss->shared_clean +
+			mss->shared_dirty +
+			mss->private_clean +
+			mss->private_dirty;
+}
+
+static void show_merged_libart_smap(struct seq_file *m,
+				    struct proc_maps_private *priv,
+				    struct vm_area_struct *vma)
+{
+	struct vma_iterator iter;
+	struct vm_area_struct *tmp;
+	struct mem_size_stats mss_total;
+	struct mem_size_stats mss_tmp;
+
+	unsigned long start = vma->vm_start;
+	unsigned long end   = vma->vm_end;
+	struct file *file = vma->vm_file;
+	struct inode *inode = file_inode(file);
+	vm_flags_t flags = vma->vm_flags;
+	unsigned long ino = inode->i_ino;
+	dev_t dev = inode->i_sb->s_dev;
+	unsigned long long pgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;
+
+	memset(&mss_total, 0, sizeof(mss_total));
+	smap_gather_stats(vma, &mss_total, 0);
+
+	iter = priv->iter;
+	while ((tmp = vma_next(&iter))) {
+		if (tmp->vm_start != end) break;
+		
+		if (tmp->vm_file) {
+			if (tmp->vm_file != file) break;
+			if (!(tmp->vm_flags & VM_EXEC)) break;
+		}
+		
+		memset(&mss_tmp, 0, sizeof(mss_tmp));
+		smap_gather_stats(tmp, &mss_tmp, 0);
+		accumulate_mem_stats(&mss_total, &mss_tmp);
+
+		end = tmp->vm_end;
+	}
+
+	sanitize_libart_stats(&mss_total);
+
+	show_vma_header_prefix(m, start, end, flags, pgoff, dev, ino);
+	seq_pad(m, ' ');
+	seq_file_path(m, file, "");
+	seq_putc(m, '\n');
+
+	SEQ_PUT_DEC("Size:           ", (end - start));
+	SEQ_PUT_DEC(" kB\nKernelPageSize: ", vma_kernel_pagesize(vma));
+	SEQ_PUT_DEC(" kB\nMMUPageSize:    ", vma_mmu_pagesize(vma));
+	seq_puts(m, " kB\n");
+
+	__show_smap(m, &mss_total, false);
+
+	seq_printf(m, "THPeligible:    %d\n",
+		   hugepage_vma_check(vma, vma->vm_flags, true, false, true));
+
+	if (arch_pkeys_enabled())
+		seq_printf(m, "ProtectionKey:  %8u\n", vma_pkey(vma));
+
+	show_smap_vma_flags(m, vma);
+}
+
+
+/////////////////////////////////////////////
+
+
 static int show_smap(struct seq_file *m, void *v)
 {
+
+    // normal
 	struct vm_area_struct *vma = v;
 	struct mem_size_stats mss;
+	
+	//bypass check
+	
+	struct proc_maps_private *priv = m->private;
+	bool bypassed = false;
 
+    if (priv->need_bypass) {
+        if (priv->shadow_start != 0 && vma->vm_start == priv->shadow_start) {
+			return 0;
+        }
+        if (is_libart_vma(vma, true)) {
+			if (!priv->libart_smap_printed) {
+				show_merged_libart_smap(m, priv, vma);
+				priv->libart_smap_printed = true;
+			}
+			return 0;
+		} else {
+			priv->libart_smap_printed = false;
+		}
+		
+        if (bypass_show_map_vma(vma) || hide_exec_vma(priv, vma)) {
+            show_anon_noperm_vma(m, vma);
+            bypassed = true;
+        }
+    }
+    		
+	// normal
+
 	memset(&mss, 0, sizeof(mss));
 
 	if (!vma_pages(vma))
@@ -890,7 +1434,10 @@
 
 	smap_gather_stats(vma, &mss, 0);
 
-	show_map_vma(m, vma);
+    // bypassed
+	if (!bypassed)
+    	show_map_vma(m, vma);
+    // normal
 
 	SEQ_PUT_DEC("Size:           ", VMA_PAD_START(vma) - vma->vm_start);
 	SEQ_PUT_DEC(" kB\nKernelPageSize: ", vma_kernel_pagesize(vma));
