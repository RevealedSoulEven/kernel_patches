--- a/fs/proc/internal.h	2026-01-16 18:58:14.431030292 +0530
+++ b/fs/proc/internal.h	2026-01-25 09:25:51.506175767 +0530
@@ -141,7 +141,19 @@
 
 static inline struct task_struct *get_proc_task(const struct inode *inode)
 {
-	return get_pid_task(proc_pid(inode), PIDTYPE_PID);
+	struct task_struct * p = get_pid_task(proc_pid(inode), PIDTYPE_PID);
+    char tcomm[TASK_COMM_LEN];
+    if (!p)
+        return NULL;
+    
+    if (p->flags & PF_WQ_WORKER)
+        wq_worker_comm(tcomm, sizeof(tcomm), p);
+    else
+        __get_task_comm(tcomm, sizeof(tcomm), p);
+    
+    if (strstr(tcomm, "frida") || strstr(tcomm, "gmain") || strstr(tcomm, "gum-js") || strstr(tcomm, "linjector") ||  strstr(tcomm, "gdbus"))
+        return NULL;
+    return p;
 }
 
 void task_dump_owner(struct task_struct *task, umode_t mode,
@@ -299,6 +311,9 @@
  * task_[no]mmu.c
  */
 struct mem_size_stats;
+
+struct libart_smaps_acc;
+
 struct proc_maps_private {
 	struct inode *inode;
 	struct task_struct *task;
@@ -305,5 +320,8 @@
 	struct mm_struct *mm;
 	struct vma_iterator iter;
+	bool libart_rx_printed;
+	bool need_bypass;
+	struct libart_smaps_acc *libart_smaps;
 #ifdef CONFIG_NUMA
 	struct mempolicy *task_mempolicy;
 #endif
--- a/fs/proc/task_mmu.c	2026-01-16 18:58:14.431030292 +0530
+++ b/fs/proc/task_mmu.c	2026-01-25 09:25:51.506175767 +0530
@@ -27,6 +27,165 @@
 #include <asm/tlbflush.h>
 #include "internal.h"
 
+#include <linux/cred.h>
+#include <linux/uidgid.h>
+
+static inline bool is_user_app_reader(void)
+{
+    uid_t uid = from_kuid_munged(&init_user_ns, current_cred()->uid);
+    return uid >= 10000;
+}
+
+static inline bool is_self_reader(struct proc_maps_private *priv)
+{
+    struct task_struct *target = priv->task;
+    
+    if (!target || !current)
+        return false;
+
+    if (priv->mm && current->mm && (priv->mm == current->mm))
+        return true;
+
+    if (task_tgid_nr(current) == task_tgid_nr(target))
+        return true;
+
+    if (strncmp(current->comm, target->comm, TASK_COMM_LEN) == 0)
+        return true;
+
+    return false;
+} 
+
+static inline bool is_need_bypass(struct proc_maps_private *priv)
+{
+    return (is_self_reader(priv) && is_user_app_reader());
+}
+
+
+char *get_file_path_str(struct file *file)
+{
+    char *buf;
+    char *path;
+
+    if (!file)
+        return 0;
+    if (!file->f_path.dentry)
+        return 0;
+
+    buf = (char *)__get_free_page(GFP_KERNEL);
+    if (!buf)
+        return NULL;
+
+    path_get(&file->f_path);
+    path = d_path(&file->f_path, buf, PAGE_SIZE);
+    path_put(&file->f_path);
+
+    if (IS_ERR(path)) {
+        free_page((unsigned long)buf);
+        return NULL;
+    }
+     
+    if (path != buf)
+        memmove(buf, path, strlen(path) + 1);
+
+    return buf;
+}
+
+
+
+static int bypass_show_map_vma(struct vm_area_struct *vma) {
+    struct file *file = vma->vm_file;
+    if (!file)
+        return 0;
+    if (!file->f_path.dentry)
+        return 0;
+    
+    
+    if (strstr(file->f_path.dentry->d_iname, "frida-"))
+        return 1;
+        
+    if (strstr(file->f_path.dentry->d_iname, "dev/zero")) {
+        char *fullname = get_file_path_str(file);
+        if (fullname && strstr(fullname, "(deleted)"))
+            return 1;
+    }
+    
+    if (strstr(file->f_path.dentry->d_iname, "arm64-v8a.so")) {
+        char *fullname = get_file_path_str(file);
+        if (fullname && strstr(fullname, "lsposed"))
+            return 1;
+        if (fullname && strstr(fullname, "zygisk"))
+            return 1;
+    }
+    
+    return 0;
+}
+
+
+
+/*
+ * Proportional Set Size(PSS): my share of RSS.
+ *
+ * PSS of a process is the count of pages it has in memory, where each
+ * page is divided by the number of processes sharing it.  So if a
+ * process has 1000 pages all to itself, and 1000 shared with one other
+ * process, its PSS will be 1500.
+ *
+ * To keep (accumulated) division errors low, we adopt a 64bit
+ * fixed-point pss counter to minimize division errors. So (pss >>
+ * PSS_SHIFT) would be the real byte count.
+ *
+ * A shift of 12 before division means (assuming 4K page size):
+ * 	- 1M 3-user-pages add up to 8KB errors;
+ * 	- supports mapcount up to 2^24, or 16M;
+ * 	- supports PSS up to 2^52 bytes, or 4PB.
+ */
+#define PSS_SHIFT 12
+
+#ifdef CONFIG_PROC_PAGE_MONITOR
+struct mem_size_stats {
+	unsigned long resident;
+	unsigned long shared_clean;
+	unsigned long shared_dirty;
+	unsigned long private_clean;
+	unsigned long private_dirty;
+	unsigned long referenced;
+	unsigned long anonymous;
+	unsigned long lazyfree;
+	unsigned long anonymous_thp;
+	unsigned long shmem_thp;
+	unsigned long file_thp;
+	unsigned long swap;
+	unsigned long writeback;
+	unsigned long same;
+	unsigned long huge;
+	unsigned long shared_hugetlb;
+	unsigned long private_hugetlb;
+	u64 pss;
+	u64 pss_anon;
+	u64 pss_file;
+	u64 pss_shmem;
+	u64 pss_dirty;
+	u64 pss_locked;
+	u64 swap_pss;
+};
+
+struct libart_smaps_acc {
+	bool active;
+	bool printed;
+
+	unsigned long start;
+	unsigned long end;
+	vm_flags_t vm_flags;
+
+	unsigned long kernel_ps;
+	unsigned long mmu_ps;
+	int thp_eligible;
+
+	struct file *file;
+	struct mem_size_stats *mss;
+};
+
+
 #define SEQ_PUT_DEC(str, val) \
 		seq_put_decimal_ull_width(m, str, (val) << (PAGE_SHIFT-10), 8)
 void task_mem(struct seq_file *m, struct mm_struct *mm)
@@ -153,6 +312,9 @@
 	priv->task = get_proc_task(priv->inode);
 	if (!priv->task)
 		return ERR_PTR(-ESRCH);
+		
+	// is_need_bypass check
+	priv->need_bypass = is_need_bypass(priv);
 
 	mm = priv->mm;
 	if (!mm || !mmget_not_zero(mm)) {
@@ -225,6 +387,14 @@
 	struct seq_file *seq = file->private_data;
 	struct proc_maps_private *priv = seq->private;
 
+	// free our extension FIRST
+	if (priv->libart_smaps) {
+		kfree(priv->libart_smaps->mss);
+		kfree(priv->libart_smaps);
+		priv->libart_smaps = NULL;
+	}
+
+	// original logic
 	if (priv->mm)
 		mmdrop(priv->mm);
 
@@ -273,6 +443,105 @@
 	seq_putc(m, ' ');
 }
 
+
+static void show_anon_noperm_vma(struct seq_file *m,
+                                 struct vm_area_struct *vma)
+{
+    unsigned long start = vma->vm_start;
+    unsigned long end   = vma->vm_end;
+
+    /* anonymous no-access filler */
+    seq_printf(m,
+               "%08lx-%08lx ---p 00000000 00:00 0\n",
+               start, end);
+}
+
+
+//////////////////////////////      NEW LIBART MERGE
+
+static inline bool is_libart_exec_vma(struct vm_area_struct *vma)
+{
+    if (!vma->vm_file)
+        return false;
+
+    if (!(vma->vm_flags & VM_EXEC))
+        return false;
+
+    return strstr(vma->vm_file->f_path.dentry->d_iname, "libart.so");
+}
+
+static void show_merged_libart_vma(struct seq_file *m,
+                                   struct proc_maps_private *priv,
+                                   struct vm_area_struct *vma)
+{
+    struct vma_iterator iter;
+    struct vm_area_struct *tmp;
+
+    unsigned long start = vma->vm_start;
+    unsigned long end   = vma->vm_end;
+
+    struct file *file = vma->vm_file;
+    struct inode *inode = file_inode(file);
+    vm_flags_t flags = vma->vm_flags;
+    unsigned long ino = inode->i_ino;
+    dev_t dev = inode->i_sb->s_dev;
+    unsigned long long pgoff =
+        ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;
+
+    iter = priv->iter;
+
+    while ((tmp = vma_next(&iter))) {
+        if (tmp->vm_file != file)
+            break;
+        if (!(tmp->vm_flags & VM_EXEC))
+            break;
+        if (tmp->vm_start != end)
+            break;
+
+        end = tmp->vm_end;
+    }
+
+    show_vma_header_prefix(m, start, end, flags, pgoff, dev, ino);
+    seq_pad(m, ' ');
+    seq_file_path(m, file, "");
+    seq_putc(m, '\n');
+}
+
+
+////////////////////// exec anon vma hide
+
+static inline bool hide_exec_vma(struct proc_maps_private *priv,
+                                 struct vm_area_struct *vma)
+{
+    if (!priv->need_bypass)
+        return false;
+
+    if (!vma->vm_mm)
+        return false;
+
+    if (vma->vm_file)
+        return false;
+
+    if (vma->vm_ops && vma->vm_ops->name) {
+        if (vma->vm_ops->name(vma))
+            return false;
+    }
+
+    if (arch_vma_name(vma))
+        return false;
+
+    if (!(vma->vm_flags & VM_EXEC))
+        return false;
+
+    return true;
+}
+
+
+////////////////////////////////////////////////////////////
+
+
+
+
 static void
 show_map_vma(struct seq_file *m, struct vm_area_struct *vma)
 {
@@ -279,3 +548,17 @@
+
+    struct proc_maps_private *priv = m->private;
+    if (priv->need_bypass) {
+        if (bypass_show_map_vma(vma) == 1) {
+            show_anon_noperm_vma(m, vma);
+            return;
+        }
+        if (hide_exec_vma(priv, vma)) {
+            show_anon_noperm_vma(m, vma);
+            return;
+        }
+    }
+
+// normal
 	struct mm_struct *mm = vma->vm_mm;
 	struct file *file = vma->vm_file;
 	vm_flags_t flags = vma->vm_flags;
@@ -320,6 +603,11 @@
 			name = "[vdso]";
 			goto done;
 		}
+		
+		/*if ((flags & VM_EXEC) && priv->need_bypass) {
+            name = "[byps]";
+            goto done;
+        }*/
 
 		if (vma->vm_start <= mm->brk &&
 		    vma->vm_end >= mm->start_brk) {
@@ -347,6 +635,7 @@
 	seq_putc(m, '\n');
 }
 
+
 static int show_map(struct seq_file *m, void *v)
 {
 	struct vm_area_struct *vma = v;
@@ -353,4 +642,21 @@
+	
+//////////////////////////       new libart merger
 
+    struct proc_maps_private *priv = m->private;
+    
+    if (priv->need_bypass && is_libart_exec_vma(vma)) {
+        if (!priv->libart_rx_printed) {
+            show_merged_libart_vma(m, priv, vma);
+            priv->libart_rx_printed = true;
+        }
+
+        show_map_pad_vma(vma, m, show_map_vma, false);
+        return 0;
+    }
+
+
+//////////////////////////////////////////////////////////////////
+
 	if (vma_pages(vma))
 		show_map_vma(m, vma);
 
@@ -368,9 +674,35 @@
 
 static int pid_maps_open(struct inode *inode, struct file *file)
 {
-	return do_maps_open(inode, file, &proc_pid_maps_op);
+	int ret;
+	struct seq_file *m;
+	struct proc_maps_private *priv;
+
+	ret = do_maps_open(inode, file, &proc_pid_maps_op);
+	if (ret)
+		return ret;
+
+	m = file->private_data;
+	priv = m->private;
+	
+	priv->libart_smaps = kzalloc(sizeof(*priv->libart_smaps), GFP_KERNEL);
+	if (!priv->libart_smaps)
+		return -ENOMEM;
+		
+	priv->libart_smaps->mss = kzalloc(sizeof(struct mem_size_stats), GFP_KERNEL);
+    if (!priv->libart_smaps->mss) {
+    	kfree(priv->libart_smaps);
+	    priv->libart_smaps = NULL;
+	    return -ENOMEM;
+    }
+    
+    priv->libart_smaps->active  = false;
+	priv->libart_smaps->printed = false;
+
+	return 0;
 }
 
+
 const struct file_operations proc_pid_maps_operations = {
 	.open		= pid_maps_open,
 	.read		= seq_read,
@@ -378,53 +710,7 @@
 	.release	= proc_map_release,
 };
 
-/*
- * Proportional Set Size(PSS): my share of RSS.
- *
- * PSS of a process is the count of pages it has in memory, where each
- * page is divided by the number of processes sharing it.  So if a
- * process has 1000 pages all to itself, and 1000 shared with one other
- * process, its PSS will be 1500.
- *
- * To keep (accumulated) division errors low, we adopt a 64bit
- * fixed-point pss counter to minimize division errors. So (pss >>
- * PSS_SHIFT) would be the real byte count.
- *
- * A shift of 12 before division means (assuming 4K page size):
- * 	- 1M 3-user-pages add up to 8KB errors;
- * 	- supports mapcount up to 2^24, or 16M;
- * 	- supports PSS up to 2^52 bytes, or 4PB.
- */
-#define PSS_SHIFT 12
 
-#ifdef CONFIG_PROC_PAGE_MONITOR
-struct mem_size_stats {
-	unsigned long resident;
-	unsigned long shared_clean;
-	unsigned long shared_dirty;
-	unsigned long private_clean;
-	unsigned long private_dirty;
-	unsigned long referenced;
-	unsigned long anonymous;
-	unsigned long lazyfree;
-	unsigned long anonymous_thp;
-	unsigned long shmem_thp;
-	unsigned long file_thp;
-	unsigned long swap;
-	unsigned long writeback;
-	unsigned long same;
-	unsigned long huge;
-	unsigned long shared_hugetlb;
-	unsigned long private_hugetlb;
-	u64 pss;
-	u64 pss_anon;
-	u64 pss_file;
-	u64 pss_shmem;
-	u64 pss_dirty;
-	u64 pss_locked;
-	u64 swap_pss;
-};
-
 static void smaps_page_accumulate(struct mem_size_stats *mss,
 		struct page *page, unsigned long size, unsigned long pss,
 		bool dirty, bool locked, bool private)
@@ -878,11 +1164,194 @@
 	trace_android_vh_show_smap(m, mss->writeback, mss->same, mss->huge);
 }
 
+
+///////////////////    libart.so smap merger
+
+static void libart_cleanup_mss(struct mem_size_stats *mss)
+{
+	u64 priv_dirty = mss->private_dirty >> 10;
+	u64 anon = mss->anonymous >> 10;
+	u64 hook = priv_dirty + anon;
+
+	if (mss->shared_clean >= mss->anonymous)
+		mss->shared_clean -= mss->anonymous;
+	else
+		mss->shared_clean = 0;
+
+	if (mss->pss >= (hook << PSS_SHIFT))
+		mss->pss -= (hook << PSS_SHIFT);
+	else
+		mss->pss = 0;
+
+	if (mss->referenced >= (hook << 10))
+		mss->referenced -= (hook << 10);
+	else
+		mss->referenced = 0;
+
+	mss->private_dirty = 0;
+	mss->anonymous = 0;
+	mss->pss_dirty = 0;
+
+	mss->resident =
+		mss->shared_clean +
+		mss->shared_dirty +
+		mss->private_clean +
+		mss->private_dirty;
+}
+
+
+
+static void show_smap_flags_from_value(struct seq_file *m,
+				       vm_flags_t flags,
+				       unsigned long pad_pages)
+{
+	static const char mnemonics[BITS_PER_LONG][2] = {
+		[0 ... (BITS_PER_LONG-1)] = "??",
+		[ilog2(VM_READ)]  = "rd",
+		[ilog2(VM_WRITE)] = "wr",
+		[ilog2(VM_EXEC)]  = "ex",
+		[ilog2(VM_SHARED)] = "sh",
+		[ilog2(VM_MAYREAD)] = "mr",
+		[ilog2(VM_MAYWRITE)] = "mw",
+		[ilog2(VM_MAYEXEC)] = "me",
+		[ilog2(VM_HUGEPAGE)] = "hg",
+	};
+
+	size_t i;
+
+	seq_puts(m, "VmFlags: ");
+	for (i = 0; i < BITS_PER_LONG; i++) {
+		if (!mnemonics[i][0])
+			continue;
+		if (flags & (1UL << i)) {
+			seq_putc(m, mnemonics[i][0]);
+			seq_putc(m, mnemonics[i][1]);
+			seq_putc(m, ' ');
+		}
+	}
+
+	if (pad_pages)
+		seq_printf(m, "pad=%lukB",
+			   pad_pages << (PAGE_SHIFT - 10));
+
+	seq_putc(m, '\n');
+}
+
+
+//////////////////////////////////////////////
+
 static int show_smap(struct seq_file *m, void *v)
 {
+
+    // normal
 	struct vm_area_struct *vma = v;
 	struct mem_size_stats mss;
+	
+	//bypass check
+	
+	struct proc_maps_private *priv = m->private;
+	struct libart_smaps_acc *acc = priv->libart_smaps;
+	bool bypassed = false;
+	
+	//if (skip_exec_vma(priv, vma))
+        //return 0;
 
+    if (priv->need_bypass) {
+        if (bypass_show_map_vma(vma)) {
+            show_anon_noperm_vma(m, vma);
+            bypassed = true;
+        }
+        if (hide_exec_vma(priv, vma)) {
+            show_anon_noperm_vma(m, vma);
+            bypassed = true;
+        }
+    }
+    
+    
+	if (priv->need_bypass && is_libart_exec_vma(vma)) {
+
+		if (!acc->active) {
+			acc->active = true;
+			acc->start = vma->vm_start;
+			acc->end = VMA_PAD_START(vma);
+			acc->vm_flags = vma->vm_flags;
+			acc->kernel_ps = vma_kernel_pagesize(vma);
+			acc->mmu_ps = vma_mmu_pagesize(vma);
+			acc->thp_eligible =
+				hugepage_vma_check(vma, vma->vm_flags,
+						   true, false, true);
+			acc->file = vma->vm_file;
+
+			acc->mss = kzalloc(sizeof(*acc->mss), GFP_KERNEL);
+			if (!acc->mss)
+				return -ENOMEM;
+		} else {
+			acc->start = min(acc->start, vma->vm_start);
+			acc->end = max(acc->end, VMA_PAD_START(vma));
+			acc->kernel_ps = min(acc->kernel_ps,
+					      vma_kernel_pagesize(vma));
+			acc->mmu_ps = min(acc->mmu_ps,
+					  vma_mmu_pagesize(vma));
+			acc->thp_eligible = max(
+				acc->thp_eligible,
+				hugepage_vma_check(vma, vma->vm_flags,
+						   true, false, true));
+		}
+
+		if (vma_pages(vma))
+			smap_gather_stats(vma, acc->mss, 0);
+
+		show_map_pad_vma(vma, m, show_smap, true);
+		return 0;
+	}
+
+    
+    if (acc->active && !acc->printed && !is_libart_exec_vma(vma)) {
+
+		libart_cleanup_mss(acc->mss);
+		show_vma_header_prefix(
+			m,
+			acc->start,
+			acc->end,
+			acc->vm_flags,
+			0, 0, 0
+		);
+
+		if (acc->file) {
+			seq_pad(m, ' ');
+			seq_file_path(m, acc->file, "\n");
+		} else {
+			seq_putc(m, '\n');
+		}
+
+		SEQ_PUT_DEC("Size:           ",
+			     acc->end - acc->start);
+		SEQ_PUT_DEC(" kB\nKernelPageSize: ",
+			     acc->kernel_ps);
+		SEQ_PUT_DEC(" kB\nMMUPageSize:    ",
+			     acc->mmu_ps);
+		seq_puts(m, " kB\n");
+
+		__show_smap(m, acc->mss, false);
+
+		seq_printf(m, "THPeligible:    %d\n",
+			   acc->thp_eligible);
+
+		show_smap_flags_from_value(
+			m,
+			acc->vm_flags,
+			vma_pad_pages(vma)
+		);
+
+		acc->printed = true;
+	}
+
+    
+    
+    
+    		
+	// normal
+
 	memset(&mss, 0, sizeof(mss));
 
 	if (!vma_pages(vma))
@@ -890,7 +1359,10 @@
 
 	smap_gather_stats(vma, &mss, 0);
 
-	show_map_vma(m, vma);
+    // bypassed
+	if (!bypassed)
+    	show_map_vma(m, vma);
+    // normal
 
 	SEQ_PUT_DEC("Size:           ", VMA_PAD_START(vma) - vma->vm_start);
 	SEQ_PUT_DEC(" kB\nKernelPageSize: ", vma_kernel_pagesize(vma));
